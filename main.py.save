from aiogram import Bot, Dispatcher, types from aiogram.types import 
InlineKeyboardButton, InlineKeyboardMarkup from aiogram.utils import 
executor import requests from bs4 import BeautifulSoup import asyncio
open .
open .



# üîê –¢–æ–∫–µ–Ω Telegram-–±–æ—Ç–∞
API_TOKEN = '7910558919:AAFlI7JWP3s-MTPV6ILpzQzgnRZSBPnSyGo'

# üì° Telegram-–∫–∞–Ω–∞–ª
CHANNEL_ID = '@forex_news_alert_100k_bot'

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

def get_main_menu():
    kb = InlineKeyboardMarkup(row_width=1)
    kb.add(
        InlineKeyboardButton("üìÖ –ù–û–í–û–°–¢–ò –î–ù–Ø", callback_data='news_today'),
        InlineKeyboardButton("üìÜ –ó–ê–í–¢–†–ê", callback_data='news_tomorrow'),
        InlineKeyboardButton("üïò –í–ê–ñ–ù–´–ï", callback_data='news_important'),
        InlineKeyboardButton("üåê –í–°–ï –ù–û–í–û–°–¢–ò –° –°–ê–ô–¢–ê", callback_data='news_all_raw')
    )
    return kb

@dp.message_handler(commands=['start'])
async def start_cmd(message: types.Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ üëá", reply_markup=get_main_menu())

@dp.callback_query_handler(lambda c: c.data.startswith('news_'))
async def callback_handler(callback_query: types.CallbackQuery):
    action = callback_query.data

    if action == 'news_all_raw':
        news = await fetch_all_forex_news_raw()
        if news:
            for item in news:
                await bot.send_message(callback_query.from_user.id, item)
        else:
            await bot.send_message(callback_query.from_user.id, "üòî –ù–æ–≤–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        await bot.answer_callback_query(callback_query.id)
        return

    await bot.send_message(callback_query.from_user.id, "‚õî –≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ –ø–æ–∫–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.")
    await bot.answer_callback_query(callback_query.id)

async def fetch_all_forex_news_raw():
    url = 'https://www.forexfactory.com/calendar'
    headers = {'User-Agent': 'Mozilla/5.0'}
    try:
        response = requests.get(url, headers=headers, timeout=10)
    except Exception as e:
        print("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:", e)
        return []

    soup = BeautifulSoup(response.text, 'html.parser')
    
    # ‚úÖ –í–ê–ñ–ù–û: –∏—â–µ–º –ø–æ class_, –∞ –Ω–µ –ø–æ id
    table = soup.find('table', class_='calendar__table')
    if not table:
        print("‚ùå –¢–∞–±–ª–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ (class='calendar__table')")
        return []

    rows = table.find_all('tr', class_='calendar__row')
    all_news = []

    for row in rows:
        time_cell = row.find('td', class_='calendar__time')
        event_cell = row.find('td', class_='calendar__event')
        impact_cell = row.find('td', class_='calendar__impact')
        currency_cell = row.find('td', class_='calendar__currency')

        if not all([time_cell, event_cell, impact_cell, currency_cell]):
            continue

        time_text = time_cell.text.strip()
        event = event_cell.text.strip()
        currency = currency_cell.text.strip()

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –≤–∞–∂–Ω–æ—Å—Ç–∏
        impact_span = impact_cell.find('span')
        if impact_span:
            classes = impact_span.get('class', [])
            if 'high' in classes:
                impact = 'üü• High'
            elif 'medium' in classes:
                impact = 'üü® Medium'
            elif 'low' in classes:
                impact = 'üü© Low'
            else:
                impact = '‚ö™ Unknown'
        else:
            impact = '‚ö™ Unknown'

        msg = f"{impact} ‚Äî {event} ({currency})\nüïí {time_text}"
        all_news.append(msg)

    print(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ –Ω–æ–≤–æ—Å—Ç–µ–π: {len(all_news)}")
    return all_news

if __name__ == '__main__':
    print("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω. –¢–∞–±–ª–∏—Ü–∞ —Ç–µ–ø–µ—Ä—å –≤–∏–¥–Ω–∞ –∏ –Ω–æ–≤–æ—Å—Ç–∏ —á–∏—Ç–∞—é—Ç—Å—è.")
    executor.start_polling(dp, skip_updates=True)
